from dotenv import load_dotenv

import os

import random
import time

load_dotenv('.env')
load_dotenv('../.env')

POWER = int(os.environ.get('POWER'))
CMWC_CYCLE = 4096
CMWC_C_MAX = 809430660

def rand32():
    """ Generate a random integer between 0 and 2**POWER.
        Shift the result 16bits to the left and execute
        a binary or operation with a new random integer
        generated between 0 and 2**POWER

        Returns:
            int: a random integer with bits size to
            represent equals to 2**POWER.
    """
    global POWER

    result = random.randint(0, pow(2, POWER))
    return result << 16 | random.randint(0, pow(2, POWER))

def init_cmwc(q, c, i, seed):
    """ Initialize the necessary variables to run
        the CMWC algorithm. Generates 4096 random
        integers and, as log the c variable is
        greater than CMWC_C_MAX, continues to
        generate, random integers for c. Return
        the initialize variables.

        Args:
            q (int): buffer with 4096 positions. All
            positions contains 0.
            c (int): Use as 0.
            i (int): Use as 0.
            seed (int): random value, to garantee
            randomness in the process. Usually is
            the current time in seconds.

        Returns:
            tuple: containing all variables initialized
            by the function. This is necessary, because
            Python doesnt update the original value
            received as parameter, it just receive a copy
            value.
    """
    global CMWC_CYCLE

    random.seed(seed)

    for i in range(CMWC_CYCLE):
        q[i] = rand32()

    while True:
        c = rand32()
        if c >= CMWC_C_MAX:
            break

    i = CMWC_CYCLE - 1
    return q, c, i

def rand_cmwc(q, c, i):
    """ TODO

        Params:
            q (int): buffer with 4096 positions. All
            positions contains random values.
            c (int): Random value, generated after n
            times calling the rand32 function.
            i (int): Usually, used as CMWC_CYCLE - 1 value

        Returns:
            int: random integer generated
    """
    global CMWC_CYCLE

    A = 18782
    M = 0xFFFFFFFE

    i = (i + 1) & (CMWC_CYCLE - 1)
    t = A * q[i] + c
    c = t >> 32
    x = t + c

    if (x < c):
        x += 1
        c += 1

    q[i] = x - M
    return q[i]

def multiply_with_carry():
    """ Implements the algorithm Multiply with carry.
    Creates a local buffer with the same length as
    CMWC_CYCLE. The algorithm suggests to use 4096 as value
    for CMWC_CYCLE. Use the current time, in sencods, as
    seed, and return the random value generated by init_cmwc
    and rand_cmwc.

    Returns:
        int: a random integer, with size proportional
        to the POWER global variable.
    """
    global CMWC_CYCLE

    q = [0] * CMWC_CYCLE
    c, i = 0, 0

    seed = int(round(time.time()))
    q, c, i = init_cmwc(q, c, i, seed)
    return rand_cmwc(q, c, i)

if __name__ == '__main__':
    print(multiply_with_carry())
